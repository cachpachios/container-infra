use std::{
    io::Write,
    path::{Path, PathBuf},
};

use anyhow::{Ok, Result};

use crate::sh::cmd;

pub fn prepare_fs(merged_path: &Path) -> Result<()> {
    let etc = merged_path.join("etc");
    if !etc.exists() {
        return Ok(()); // Probably statically linked container
    }

    // Write nameserver 8.8.8.8 to resolve.conf
    std::fs::File::create(etc.join("resolv.conf"))?
        .write_all("# Generated by the user agent\nnameserver 8.8.8.8\n".as_bytes())?;

    // Write hostname to hostname
    std::fs::File::create(etc.join("hostname"))?.write_all("node\n".as_bytes())?;

    // Write hostname to hosts
    std::fs::File::create(etc.join("hosts"))?.write_all(
        "# Generated by the user agent\n127.0.0.1 localhost\n127.0.1.1 node".as_bytes(),
    )?;

    Ok(())
}

pub fn create_overlay_fs<T: AsRef<Path>>(merged_path: T, work_path: T, layers: &Vec<PathBuf>) {
    cmd(&[
        "mount",
        "-t",
        "overlay",
        "overlay",
        "-o",
        &format!(
            "lowerdir={},upperdir={},workdir={}",
            layers
                .iter()
                .map(|layer| layer.to_str().unwrap())
                .collect::<Vec<&str>>()
                .join(":"),
            merged_path.as_ref().to_str().unwrap(),
            work_path.as_ref().to_str().unwrap()
        ),
        merged_path.as_ref().to_str().unwrap(),
    ]);
}
